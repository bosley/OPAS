#ifndef BSPEC_0_HPP
#define BSPEC_0_HPP

#include <stdint.h>

namespace BS0 {

    // Data buffer generated by encode methods, and consumed by decode methods
    struct Buffer {
        uint8_t data[32];
    };

    // Device information as described in input_spec_0x00
    struct DeviceInfo {
        uint8_t node_id;
        uint8_t num_devices;
        uint8_t device_list[27];
    };

    // Sensor ids
    enum class SensorId {
        STATUS      = 0x0,
        TEMPERATURE = 0x1,
        HUMIDITY    = 0x2,
        MOVEMENT    = 0x3,
        BUTTON      = 0x4,
        LIGHT_SENSOR= 0x5,
        UNKNOWN     = 0xFF
    };

    // Temperatures recognized by spec 0x00
    enum class TemperatureType {
        FAHRENHEIT = 0x0,
        CELSIUS    = 0x1,
        KELVIN     = 0x2,
        RANKINE    = 0x3,
        UNKNOWN    = 0xFF
    };

    // Decode what type of sensor the data came from so it can be routed to the correct
    // decode function by the user
    SensorId getOriginSensor(Buffer &buffer) {
        switch(static_cast<SensorId>(buffer.data[2])) {
            case SensorId::STATUS:      return SensorId::STATUS;
            case SensorId::TEMPERATURE: return SensorId::TEMPERATURE;
            case SensorId::HUMIDITY:    return SensorId::HUMIDITY;
            case SensorId::MOVEMENT:    return SensorId::MOVEMENT;
            case SensorId::BUTTON:      return SensorId::BUTTON;
            case SensorId::LIGHT_SENSOR:return SensorId::LIGHT_SENSOR;
            default:
                return SensorId::UNKNOWN;
        }
    }

    //  Encode a device status
    static Buffer encodeDeviceInfo(DeviceInfo dev) {

        Buffer buffer;
        buffer.data[0] = 0x00;        // Spec   ID
        buffer.data[1] = dev.node_id; // Node   ID
        buffer.data[2] = 0x00;
        buffer.data[3] = 0x00;
        buffer.data[4] = dev.num_devices;

        for(uint8_t i = 0; i < 27; i++) {
            buffer.data[i+5] = dev.device_list[i];
        }
        return buffer;
    }

    //  Decode a device status
    static bool decodeDeviceInfo(Buffer &buffer, DeviceInfo &dev) {

        // Ensure its of spec 0x00
        if( buffer.data[0] != 0x00 ) { return false; }

        // Ensure that the data is actually a temperature thing
        SensorId sanity_check = getOriginSensor(buffer);
        if( sanity_check != SensorId::STATUS) { return false; }

        // Get the node id
        dev.node_id = buffer.data[1];

        if(buffer.data[2] != 0 || buffer.data[3] != 0) {
            return false;
        }

        dev.num_devices = buffer.data[4];

        for(uint8_t i = 0; i < 27; i++) {
            dev.device_list[i] = buffer.data[i+5];
        }

        return true;
    }

    //  Encode a temperature value and receive a sendable buffer. 
    //  node_id : The unique id for the node
    //  type    : The type of temperature
    //  temperature : The temperature value
    //  sub_id  : The sub-id of the sensor. Defaults to 0 
    static Buffer encodeTemperature(uint8_t node_id, TemperatureType type, float temperature, uint8_t sub_id=0x00) {

        uint32_t value = static_cast<uint32_t>(temperature * 100.00);

        Buffer buffer;
        buffer.data[0] = 0x00;    // Spec   ID
        buffer.data[1] = node_id; // Node   ID
        buffer.data[2] = static_cast<uint8_t>(SensorId::TEMPERATURE);
        buffer.data[3] = sub_id;

        buffer.data[4] = static_cast<uint8_t>(type);

        buffer.data[5] = value >> 24;
        buffer.data[6] = value >> 16;
        buffer.data[7] = value >>  8;
        buffer.data[8] = value >>  0;

        return buffer;
    }

    // Decode a buffer into its temperature parts
    // Returns true if the data contained indicated that its origin sensor matches the expected type for the function
    // and the given spec matches Spec 0x00
    static bool decodeTemperature(Buffer &buffer, uint8_t &node_id, TemperatureType &type, float &temperature, uint8_t &sub_id) {

        // Ensure its of spec 0x00
        if( buffer.data[0] != 0x00 ) { return false; }

        // Ensure that the data is actually a temperature thing
        SensorId sanity_check = getOriginSensor(buffer);
        if( sanity_check != SensorId::TEMPERATURE) { return false; }

        // Get the node id
        node_id = buffer.data[1];
        
        // Ensure the temperature value is valid and set it - return false if not valid
        switch(static_cast<TemperatureType>(buffer.data[4])) {
            case TemperatureType::CELSIUS:    type = TemperatureType::CELSIUS;    break;
            case TemperatureType::FAHRENHEIT: type = TemperatureType::FAHRENHEIT; break;
            case TemperatureType::RANKINE:    type = TemperatureType::RANKINE;    break;
            case TemperatureType::KELVIN:     type = TemperatureType::KELVIN;     break;
            default:
                return false;
        }

        // Sensor sub id
        sub_id = buffer.data[3];

        uint32_t raw = static_cast<uint32_t>(buffer.data[5]) << 24 | 
                       static_cast<uint32_t>(buffer.data[6]) << 16 |
                       static_cast<uint32_t>(buffer.data[7]) <<  8 |
                       static_cast<uint32_t>(buffer.data[8]) <<  0 ;  

        temperature = static_cast<float>(raw);

        temperature /= 100.0;

        return true;
    }

    //  Encode a humidity value and receive a sendable buffer. 
    //  node_id : The unique id for the node
    //  type    : The type of temperature
    //  humidity : The humidity value
    //  sub_id  : The sub-id of the sensor. Defaults to 0 
    static Buffer encodeHumidity(uint8_t node_id, float humidity, uint8_t sub_id=0x00) {

        uint32_t value = static_cast<uint32_t>(humidity * 100.00);

        Buffer buffer;
        buffer.data[0] = 0x00;    // Spec   ID
        buffer.data[1] = node_id; // Node   ID
        buffer.data[2] = static_cast<uint8_t>(SensorId::HUMIDITY);
        buffer.data[3] = sub_id;

        buffer.data[4] = value >> 24;
        buffer.data[5] = value >> 16;
        buffer.data[6] = value >>  8;
        buffer.data[7] = value >>  0;

        return buffer;
    }

    // Decode a buffer into its humidity parts
    // Returns true if the data contained indicated that its origin sensor matches the expected type for the function
    // and the given spec matches Spec 0x00
    static bool decodeHumidity(Buffer &buffer, uint8_t &node_id, float &humidity, uint8_t &sub_id) {

        // Ensure its of spec 0x00
        if( buffer.data[0] != 0x00 ) { return false; }

        // Ensure that the data is actually a humidity thing
        SensorId sanity_check = getOriginSensor(buffer);
        if( sanity_check != SensorId::HUMIDITY) { return false; }

        // Get the node id
        node_id = buffer.data[1];

        // Sensor sub id
        sub_id = buffer.data[3];

        uint32_t raw = static_cast<uint32_t>(buffer.data[4]) << 24 | 
                       static_cast<uint32_t>(buffer.data[5]) << 16 |
                       static_cast<uint32_t>(buffer.data[6]) <<  8 |
                       static_cast<uint32_t>(buffer.data[7]) <<  0 ;  

        humidity = static_cast<float>(raw);

        humidity /= 100.0;

        return true;
    }

    //  Encode a movement value and receive a sendable buffer. 
    //  node_id : The unique id for the node
    //  type    : The type of temperature
    //  movement_active : 1 if the there is movement, 0 if ceased
    static Buffer encodeMovement(uint8_t node_id, bool movement_active, uint8_t sub_id=0x00) {

        Buffer buffer;
        buffer.data[0] = 0x00;    // Spec   ID
        buffer.data[1] = node_id; // Node   ID
        buffer.data[2] = static_cast<uint8_t>(SensorId::MOVEMENT);
        buffer.data[3] = sub_id;

        buffer.data[4] = static_cast<uint8_t>(movement_active);

        return buffer;
    }

    // Decode a buffer into its movement parts
    // Returns true if the data contained indicated that its origin sensor matches the expected type for the function
    // and the given spec matches Spec 0x00
    static bool decodeMovement(Buffer &buffer, uint8_t &node_id, bool &movement_active, uint8_t &sub_id) {

        // Ensure its of spec 0x00
        if( buffer.data[0] != 0x00 ) { return false; }

        // Ensure that the data is actually a movement thing
        SensorId sanity_check = getOriginSensor(buffer);
        if( sanity_check != SensorId::MOVEMENT) { return false; }

        // Get the node id
        node_id = buffer.data[1];

        // Sensor sub id
        sub_id = buffer.data[3];

        movement_active = static_cast<bool>(buffer.data[4]);

        return true;
    }

    //  Encode a button value and receive a sendable buffer. 
    //  node_id : The unique id for the node
    //  type    : The type of temperature
    //  button_active : The button value, 1 if active, 0 if not active
    static Buffer encodeButton(uint8_t node_id, bool button_active, uint8_t sub_id=0x00) {

        Buffer buffer;
        buffer.data[0] = 0x00;    // Spec   ID
        buffer.data[1] = node_id; // Node   ID
        buffer.data[2] = static_cast<uint8_t>(SensorId::BUTTON);
        buffer.data[3] = sub_id;

        buffer.data[4] = static_cast<uint8_t>(button_active);

        return buffer;
    }

    // Decode a buffer into its button parts
    // Returns true if the data contained indicated that its origin sensor matches the expected type for the function
    // and the given spec matches Spec 0x00
    static bool decodeButton(Buffer &buffer, uint8_t &node_id, bool &button_active, uint8_t &sub_id) {

        // Ensure its of spec 0x00
        if( buffer.data[0] != 0x00 ) { return false; }

        // Ensure that the data is actually a button thing
        SensorId sanity_check = getOriginSensor(buffer);
        if( sanity_check != SensorId::BUTTON) { return false; }

        // Get the node id
        node_id = buffer.data[1];

        // Sensor sub id
        sub_id = buffer.data[3];

        button_active = static_cast<bool>(buffer.data[4]);

        return true;
    }

    //  Encode a button value and receive a sendable buffer. 
    //  node_id : The unique id for the node
    //  type    : The type of temperature
    //  sensor_value : The value of the light sensor
    static Buffer encodeLightSensor(uint8_t node_id, uint16_t sensor_value, uint8_t sub_id=0x00) {

        Buffer buffer;
        buffer.data[0] = 0x00;    // Spec   ID
        buffer.data[1] = node_id; // Node   ID
        buffer.data[2] = static_cast<uint8_t>(SensorId::LIGHT_SENSOR);
        buffer.data[3] = sub_id;
        buffer.data[4] = sensor_value >>  8;
        buffer.data[5] = sensor_value >>  0;

        return buffer;
    }

    // Decode a buffer into its light sensor parts
    // Returns true if the data contained indicated that its origin sensor matches the expected type for the function
    // and the given spec matches Spec 0x00
    static bool decodeLightSensor(Buffer &buffer, uint8_t &node_id, uint16_t &sensor_readout, uint8_t &sub_id) {

        // Ensure its of spec 0x00
        if( buffer.data[0] != 0x00 ) { return false; }

        // Ensure that the data is actually a light sensor thing
        SensorId sanity_check = getOriginSensor(buffer);
        if( sanity_check != SensorId::LIGHT_SENSOR) { return false; }

        // Get the node id
        node_id = buffer.data[1];

        // Sensor sub id
        sub_id = buffer.data[3];

        sensor_readout = static_cast<uint16_t>(buffer.data[4]) << 8 | 
                         static_cast<uint16_t>(buffer.data[5]) << 0 ;
        return true;
    }
}

#endif