#Hardware Interaction and triggering

External devices handled by xns are handled by generated filed that are spun by configure.py based on a skeleton file. There are two types of methods that each device can have, and each device can have any number of each. These methods are 'routines' and 'slots.' Routines are methods called by core upon every 'rotation.' Routines are meant for passive monitoring, or performing some sort of check that you may want to have trigger a reaction. Slots are methods that sit quietly until called manually either by the local node, or a remote node.

Example skeleton file. 
```
name:motion_sensor
routine:check_motion
#
name:temp_sensor
routine:check_for_overheat
slot:get_temp
stream:F,C,K
#
name:light_switch
slot:turn_on
slot:turn_off
slot:toggle
```

This skeleton file will produce three .py files in xnsexternal, and tie their respective slots/routines together into the the existing _router.py

_router.py after skeleton file is spun:

```
#!python

'''

    Josh A. Bosley 
    The device router serves as a means to interact with devices in a 
    signal/slot-like relation. The device monitor thread of XNS will
    routinely run each device's methods stored in their respective
    routine dictionaries. If an action is meant to trigger a resoinse,
    the method will return a command string back to the device monitor to
    carry out the action.
    When requested, xns will run the device's methods stored in their slot 
    dictionaries as-to allow remote control off a device (From another node.)

    This file is rewritten when running the command : 

            ./configure source devices

'''

from .light_switch import routines as light_switch_routines
from .light_switch import slots as light_switch_slots
from .motion_sensor import routines as motion_sensor_routines
from .motion_sensor import slots as motion_sensor_slots
from .temp_sensor import routines as temp_sensor_routines
from .temp_sensor import slots as temp_sensor_slots


devRouter = {
        "light_switch": (light_switch_routines, light_switch_slots),
        "motion_sensor": (motion_sensor_routines, motion_sensor_slots),
        "temp_sensor": (temp_sensor_routines, temp_sensor_slots),
}
```

It is best to NEVER manually edit the _router.py file. Use *configure.py* to make edits. 

##Adding code to the generated files

For this example, we will use the light_switch file that was generated: 
```
#!python
'''
        This file was generated by configure.py

        slots: 
            Use slots to respond to an inquiry from
            a remote node. 

        routines:
            Routines are constantly ran to allow
            changes in a device (measurement, etc) 
            a chance to trigger an event.
'''

# Generated Slots

def slot_turn_on_0(stream):
    return "_UNSET_"

def slot_turn_off_1(stream):
    return "_UNSET_"

def slot_toggle_2(stream):
    return "_UNSET_"

# Generated Routines

# Routed dictionaries
slots = {
    "turn_on": slot_turn_on_0,
    "turn_off": slot_turn_off_1,
    "toggle": slot_toggle_2,
}
routines = {}
```

It is important to note that this file specifically wasn't created with any routines at all. This is because no routines were defined for the light switch (Which makes sense in some use-cases.) No routines means that this device isn't read from ever, and only ever told to perform an action. 

The dictionaries placed at the bottom of the file shouldn't be messed with ever, and its equally important that the methods are never renamed. The configure.py script ensures uniqueness in method naming, and uses these names to tie it into xns. 

Adding code is simple, just insert the code into the methods and make sure you always return a string. If the value exists as an int, double, or float, cast it to string before returning. Never return None - This is read as an error.